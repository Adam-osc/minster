### THIS FILE IS AUTOGENERATED. DO NOT EDIT THIS FILE DIRECTLY ###
from .statistics_pb2_grpc import *
import statistics_pb2
from .statistics_pb2 import *
from ._support import MessageWrapper, ArgumentError

__all__ = [
    "StatisticsService",
    "StreamDutyTimeRequest",
    "StreamDutyTimeResponse",
    "StreamReadLengthRequest",
    "StreamReadLengthResponse",
    "StreamHeatmapRequest",
    "StreamHeatmapResponse",
    "StreamThroughputRequest",
    "StreamThroughputResponse",
]

class StatisticsService(object):
    def __init__(self, channel):
        self._stub = StatisticsServiceStub(channel)
        self._pb = statistics_pb2

    def stream_duty_time(self, _message=None, _timeout=None, **kwargs):
        """
        Tracks how much time has been spent in each channel state, aggregated across all the channels

        Will fail with FAILED_PRECONDITION if minknow is not acquiring data unless `wait_for_processing` is set to True,
        then it will block and wait for data to start acquiring.

        The first response will give you all the data it can

        Since 1.13

        :param step: (required)
            Defines (in seconds) the bucket period of the duty time data

            Will fail with INVALID_ARGUMENT if `step` is below 60
            Will fail with INVALID_ARGUMENT if `step` is not a multiple of 60
            TODO: maximum size?
        :param start_time:
            Specify the start time of the data since the start time of the experiment (in seconds). If not specified then will return data since the start of the experiment

            Will fail with INVALID_ARGUMENT if not a multiple of `step`. (TODO: maybe round to closest value instead of failing?)

            For example, if this was set to 600 with a step of 60, then the first 10 buckets will not be returned
            and the first bucket will be [600,660)
        :param end_time:
            Specify the end time of the data (in seconds). Call will return if the end time has been reached.
            If the end time has not yet been reached, then the stream will continue until it has, and then return.
            If not specified, then will stream forever
            If `end_time` is 0, then this will count as not specified and will stream forever

            Will fail with INVALID_ARGUMENT if not a multiple of `step`
            Will fail with INVALID_ARGUMENT if not more than `start_time`

            This specifies T1 for a bucket [T0, T1)
        :param wait_for_processing:
            If `wait_for_processing` is true, then will wait until minknow starts acquiring data instead
            of returning with an error

            Defaults to false
        :rtype: StreamDutyTimeResponse
        """
        if _message is not None:
            return MessageWrapper(self._stub.stream_duty_time(_message, timeout=_timeout), unwraps=[])

        unused_args = set(kwargs.keys())

        _message = StreamDutyTimeRequest()

        if 'step' in kwargs:
            unused_args.remove('step')
            _message.step = kwargs['step']
        else:
            raise ArgumentError("stream_duty_time requires a 'step' argument")

        if 'start_time' in kwargs:
            unused_args.remove('start_time')
            _message.start_time = kwargs['start_time']

        if 'end_time' in kwargs:
            unused_args.remove('end_time')
            _message.end_time = kwargs['end_time']

        if 'wait_for_processing' in kwargs:
            unused_args.remove('wait_for_processing')
            _message.wait_for_processing = kwargs['wait_for_processing']

        if len(unused_args) > 0:
            raise ArgumentError("stream_duty_time got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.stream_duty_time(_message, timeout=_timeout), unwraps=[])


