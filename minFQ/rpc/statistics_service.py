### THIS FILE IS AUTOGENERATED. DO NOT EDIT THIS FILE DIRECTLY ###
from .statistics_pb2_grpc import *
from . import statistics_pb2
from minFQ.rpc.statistics_pb2 import *
from minFQ.rpc._support import MessageWrapper, ArgumentError

__all__ = [
    "StatisticsService",
    "StreamDutyTimeRequest",
    "StreamDutyTimeResponse",
    "GetDutyTimeRequest",
    "GetDutyTimeResponse",
    "StreamReadLengthRequest",
    "StreamReadLengthResponse",
    "StreamHeatmapRequest",
    "StreamHeatmapResponse",
    "StreamCumulativeThroughputRequest",
    "CumulativeThroughputBucket",
    "StreamCumulativeThroughputResponse",
    "GetCumulativeThroughputRequest",
    "GetCumulativeThroughputResponse",
    "TimeUnit",
    "SECONDS",
    "MINUTES",
]

class StatisticsService(object):
    def __init__(self, channel):
        self._stub = StatisticsServiceStub(channel)
        self._pb = statistics_pb2

    def stream_duty_time(self, _message=None, _timeout=None, **kwargs):
        """
        Tracks how much time has been spent in each channel state, aggregated across all the channels

        Will fail with FAILED_PRECONDITION if minknow is not acquiring data unless `wait_for_processing` is set to True,
        then it will block and wait for data to start acquiring.

        The first response will give you all the data it can

        Since 1.13

        :param step: (required)
            Defines (in seconds) the bucket period of the duty time data

            Will fail with INVALID_ARGUMENT if `step` is below 60
            Will fail with INVALID_ARGUMENT if `step` is not a multiple of 60
            TODO: maximum size?
        :param start_time:
            Specify the start time of the data since the start time of the experiment (in seconds). If not specified then will return data since the start of the experiment

            Will fail with INVALID_ARGUMENT if not a multiple of `step`. (TODO: maybe round to closest value instead of failing?)

            For example, if this was set to 600 with a step of 60, then the first 10 buckets will not be returned
            and the first bucket will be [600,660)
        :param end_time:
            Specify the end time of the data (in seconds). Call will return if the end time has been reached.
            If the end time has not yet been reached, then the stream will continue until it has, and then return.
            If not specified, then will stream forever
            If `end_time` is 0, then this will count as not specified and will stream forever

            Will fail with INVALID_ARGUMENT if not a multiple of `step`
            Will fail with INVALID_ARGUMENT if not more than `start_time`

            This specifies T1 for a bucket [T0, T1)
        :param wait_for_processing:
            If `wait_for_processing` is true, then will wait until minknow starts acquiring data instead
            of returning with an error

            Defaults to false
        :rtype: StreamDutyTimeResponse
        """
        if _message is not None:
            return MessageWrapper(self._stub.stream_duty_time(_message, timeout=_timeout), unwraps=[])

        unused_args = set(kwargs.keys())

        _message = StreamDutyTimeRequest()

        if 'step' in kwargs:
            unused_args.remove('step')
            _message.step = kwargs['step']
        else:
            raise ArgumentError("stream_duty_time requires a 'step' argument")

        if 'start_time' in kwargs:
            unused_args.remove('start_time')
            _message.start_time = kwargs['start_time']

        if 'end_time' in kwargs:
            unused_args.remove('end_time')
            _message.end_time = kwargs['end_time']

        if 'wait_for_processing' in kwargs:
            unused_args.remove('wait_for_processing')
            _message.wait_for_processing = kwargs['wait_for_processing']

        if len(unused_args) > 0:
            raise ArgumentError("stream_duty_time got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.stream_duty_time(_message, timeout=_timeout), unwraps=[])

    def get_duty_time(self, _message=None, _timeout=None, **kwargs):
        """
        Gets a decimated history of the duty time for a particular acquisition period. Minimum time is 15 minutes per bucket

        Since 1.14

        :param run_id: (required)
            The acquisition id of the experiment.
        :param step: (required)
            Defines the bucket period of the duty time data. Cannot be below 15 minutes (900 seconds). The time unit is defined in `time_unit`.

            Will fail with INVALID_ARGUMENT if not a multiple of 15 minutes (or equivalent in seconds)
        :param start_time:
            Specify the start time of the data since the start time of the experiment. If not specified then will return data since the start of the experiment. Time unit defined in `time_unit`
        :param end_time:
            Specify the end time of the data. Call will return if the end time has been reached. Time unit defined in `time_unit`
            If not specified then will return all the data till the end of the experiment
        :param time_unit:
            What unit of time are the other arguments specified in. Defaults to SECONDS
        :rtype: GetDutyTimeResponse
        """
        if _message is not None:
            return MessageWrapper(self._stub.get_duty_time(_message, timeout=_timeout), unwraps=[])

        unused_args = set(kwargs.keys())

        _message = GetDutyTimeRequest()

        if 'run_id' in kwargs:
            unused_args.remove('run_id')
            _message.run_id = kwargs['run_id']
        else:
            raise ArgumentError("get_duty_time requires a 'run_id' argument")

        if 'step' in kwargs:
            unused_args.remove('step')
            _message.step = kwargs['step']
        else:
            raise ArgumentError("get_duty_time requires a 'step' argument")

        if 'start_time' in kwargs:
            unused_args.remove('start_time')
            _message.start_time = kwargs['start_time']

        if 'end_time' in kwargs:
            unused_args.remove('end_time')
            _message.end_time = kwargs['end_time']

        if 'time_unit' in kwargs:
            unused_args.remove('time_unit')
            _message.time_unit = kwargs['time_unit']

        if len(unused_args) > 0:
            raise ArgumentError("get_duty_time got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.get_duty_time(_message, timeout=_timeout), unwraps=[])

    def stream_throughput(self, _message=None, _timeout=None, **kwargs):
        """
        Tracks experiment throughput across all channels over time

        The first response will give you all the data it can.

        The stream will end once the current acquisition period ends, and a caller will need to
        reinvoke the rpc in order to get new throughput data.

        Since 1.14

        :param step: (required)
            Defines (in seconds) the bucket period of the throughput

            The minimum size for `step` is 60
            TODO: maximum size?
        :param start_time:
            Specify the start time of the throughput data (in seconds). If not specified then will return data since the start of the experiment

            Will fail with INVALID_ARGUMENT if not a multiple of `step`. (TODO: maybe round to closest value instead of failing?)

            For example, if this was set to 600 with a step of 60, then the first 10 buckets will not be returned
            and the first bucket will be [600,660)
        :param end_time:
            Specify the end time of the data (in seconds). Call will return if the end time has been reached.
            If the end time has not yet been reached, then the stream will continue until it has, and then return.
            If not specified, then will stream forever

            Will fail with INVALID_ARGUMENT if not a multiple of `step`
            Will fail with INVALID_ARGUMENT if not more than `start_time`

            This specifies T1 for a bucket [T0, T1)
        :param wait_for_processing:
            If `wait_for_processing` is true, then will wait until minknow starts acquisiting data instead of returning with an error

            Defaults to false
        :rtype: StreamCumulativeThroughputResponse
        """
        if _message is not None:
            return MessageWrapper(self._stub.stream_throughput(_message, timeout=_timeout), unwraps=[])

        unused_args = set(kwargs.keys())

        _message = StreamCumulativeThroughputRequest()

        if 'step' in kwargs:
            unused_args.remove('step')
            _message.step = kwargs['step']
        else:
            raise ArgumentError("stream_throughput requires a 'step' argument")

        if 'start_time' in kwargs:
            unused_args.remove('start_time')
            _message.start_time = kwargs['start_time']

        if 'end_time' in kwargs:
            unused_args.remove('end_time')
            _message.end_time = kwargs['end_time']

        if 'wait_for_processing' in kwargs:
            unused_args.remove('wait_for_processing')
            _message.wait_for_processing = kwargs['wait_for_processing']

        if len(unused_args) > 0:
            raise ArgumentError("stream_throughput got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.stream_throughput(_message, timeout=_timeout), unwraps=[])

    def get_throughput(self, _message=None, _timeout=None, **kwargs):
        """
        Gets a decimated history of the cumulative throughput for a particular acquisition period. Minimum time is 15 minutes per bucket

        Since 1.14

        :param run_id: (required)
            The acquisition id of the experiment.
        :param step: (required)
            Defines the bucket period of the throughput data. Cannot be below 15 minutes (900 seconds). The time unit is defined in `time_unit`.

            Will fail with INVALID_ARGUMENT if not a multiple of 15 minutes (or equivalent in seconds)
        :param start_time:
            Specify the start time of the data since the start time of the experiment. If not specified then will return data since the start of the experiment. Time unit defined in `time_unit`
        :param end_time:
            Specify the end time of the data. Call will return if the end time has been reached. Time unit defined in `time_unit`
            If not specified then will return all the data till the end of the experiment
        :param time_unit:
            What unit of time are the other arguments specified in. Defaults to SECONDS
        :rtype: GetCumulativeThroughputResponse
        """
        if _message is not None:
            return MessageWrapper(self._stub.get_throughput(_message, timeout=_timeout), unwraps=[])

        unused_args = set(kwargs.keys())

        _message = GetCumulativeThroughputRequest()

        if 'run_id' in kwargs:
            unused_args.remove('run_id')
            _message.run_id = kwargs['run_id']
        else:
            raise ArgumentError("get_throughput requires a 'run_id' argument")

        if 'step' in kwargs:
            unused_args.remove('step')
            _message.step = kwargs['step']
        else:
            raise ArgumentError("get_throughput requires a 'step' argument")

        if 'start_time' in kwargs:
            unused_args.remove('start_time')
            _message.start_time = kwargs['start_time']

        if 'end_time' in kwargs:
            unused_args.remove('end_time')
            _message.end_time = kwargs['end_time']

        if 'time_unit' in kwargs:
            unused_args.remove('time_unit')
            _message.time_unit = kwargs['time_unit']

        if len(unused_args) > 0:
            raise ArgumentError("get_throughput got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.get_throughput(_message, timeout=_timeout), unwraps=[])


